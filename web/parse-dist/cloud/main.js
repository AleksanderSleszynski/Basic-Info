// Generated by IcedCoffeeScript 108.0.9
var Patch, app, async, checkVanity, crypto, express, getRecord, makeHash;

express = require('express');

crypto = require('crypto');

async = require('cloud/async.js');

app = express();

Patch = (function() {
  var _extract, _extractHash, _oldVals, _saveAtomicUpdates, _setOldVal, _vals;

  Patch.KEY = 'key';

  Patch.HASH = 'hash';

  Patch.VANITY = 'vanity';

  Patch.PHONE = 'phone';

  Patch.CITY = 'city';

  Patch.COUNTRY = 'country';

  Patch.VANITY_LOWER = Patch.VANITY + 'LowerCase';

  Patch.PHONE_UPDATED = Patch.PHONE + 'Updated';

  Patch.LOCATION_UPDATED = 'locationUpdated';

  _vals = {};

  _oldVals = {};

  Patch.prototype.getHash = function() {
    return _vals[Patch.HASH];
  };

  _extractHash = function(body) {
    var key;
    key = body[Patch.KEY];
    if (key == null) {
      throw "key is required and missing";
    }
    return _vals[Patch.HASH] = makeHash(key);
  };

  _extract = function(body, what) {
    var val;
    val = body[what];
    if (!val) {
      return;
    }
    _vals[what] = val.trim();
    switch (what) {
      case Patch.VANITY:
        return _vals[Patch.VANITY_LOWER] = _vals[what].toLowerCase();
      case Patch.PHONE:
        return _vals[Patch.PHONE_UPDATED] = new Date();
      case Patch.CITY:
      case Patch.COUNTRY:
        return _vals[Patch.LOCATION_UPDATED] = new Date();
    }
  };

  function Patch(body) {
    _extractHash(body);
    _extract(body, Patch.VANITY);
    _extract(body, Patch.PHONE);
    _extract(body, Patch.CITY);
    _extract(body, Patch.COUNTRY);
  }

  Patch.prototype.applyUpdates = function(record, cb) {
    var key, val;
    for (key in _vals) {
      val = _vals[key];
      record.set(key, val);
    }
    return record.save(null, cb);
  };

  _setOldVal = function(what, newVal, oldVal, cb) {
    if (oldVal === newVal) {
      switch (what) {
        case Patch.PHONE:
          _vals[Patch.PHONE_UPDATED] = void 0;
          delete _vals[Patch.PHONE_UPDATED];
          break;
        case Patch.CITY:
        case Patch.COUNTRY:
          _vals[Patch.LOCATION_UPDATED] = void 0;
          delete _vals[Patch.LOCATION_UPDATED];
      }
      return cb(null, false);
    }
    if (what !== Patch.VANITY) {
      _oldVals[what] = oldVal;
      return cb(null, true);
    } else {
      return checkVanity(newVal, function(err, hit) {
        if (err) {
          return cb(err);
        }
        if (!hit) {
          _oldVals[what] = oldVal;
          return cb(null, true);
        } else {
          return cb('vanity taken');
        }
      });
    }
  };

  _saveAtomicUpdates = function() {
    var Updates, key, update, val, _results;
    _results = [];
    for (key in _oldVals) {
      val = _oldVals[key];
      Updates = Parse.Object.extend('Updates');
      update = new Updates();
      update.set(Patch.HASH, _vals[Patch.HASH]);
      update.set('key', key);
      update.set('oldVal', _oldVals[key]);
      update.set('newVal', _vals[key]);
      _results.push(update.save());
    }
    return _results;
  };

  Patch.prototype.setPrevious = function(record, cb) {
    var fn, key, list, val;
    fn = function(key, newVal, oldVal) {
      return function(lcb) {
        return _setOldVal(key, newVal, oldVal, lcb);
      };
    };
    list = {};
    for (key in _vals) {
      val = _vals[key];
      if (key !== Patch.HASH) {
        list[key] = fn(key, val, record.get(key));
      }
    }
    return async.parallel(list, function(err, changed) {
      if (err) {
        return cb(err);
      }
      _saveAtomicUpdates();
      return cb(null, changed);
    });
  };

  return Patch;

})();

app.use(express.bodyParser());

makeHash = function(string) {
  return crypto.createHash('sha256').update('' + string).digest('hex').substring(0, 8);
};

checkVanity = function(vanity, cb) {
  var hashQuery, vanityLower, vanityQuery;
  vanityLower = vanity.toLowerCase();
  hashQuery = new Parse.Query('Latest');
  hashQuery.equalTo(Patch.HASH, vanityLower);
  vanityQuery = new Parse.Query('Latest');
  vanityQuery.equalTo(Patch.VANITY_LOWER, vanityLower);
  return Parse.Query.or(hashQuery, vanityQuery).first({
    success: function(o) {
      return cb(null, o);
    },
    error: function(err) {
      return cb(err);
    }
  });
};

getRecord = function(hash, cb) {
  var q;
  q = new Parse.Query('Latest');
  q.equalTo('hash', hash);
  return q.find({
    success: function(records) {
      switch (records.length) {
        case 0:
          return cb.create();
        case 1:
          return cb.update(records[0]);
        default:
          return cb.error('too many records');
      }
    },
    error: cb.error
  });
};

app.get('/favicon.ico', function(req, res) {
  res.send(404, 'nope.');
});

app.get('/:id', function(req, res) {
  var id, _ref;
  id = (_ref = req.params.id) != null ? _ref : '';
  return checkVanity(id, function(err, o) {
    if (err) {
      res.jsonp({
        error: err
      });
      return;
    }
    if (!o) {
      res.jsonp(404, {});
      return;
    }
    return res.jsonp(200, {
      vanity: o != null ? o.get('vanity') : void 0,
      hash: o != null ? o.get('hash') : void 0,
      phone: o != null ? o.get('phone') : void 0,
      phoneUpdated: o != null ? o.get('phoneUpdated') : void 0,
      location: {
        updated: o != null ? o.get('locationUpdated') : void 0,
        city: o != null ? o.get('city') : void 0,
        country: o != null ? o.get('country') : void 0
      }
    });
  });
});

app.post('/update', function(req, res) {
  var error, patch;
  try {
    patch = new Patch(req.body);
  } catch (_error) {
    error = _error;
    res.json(500, error);
    return;
  }
  return getRecord(patch.getHash(), {
    create: function() {
      var Latest, record;
      Latest = Parse.Object.extend('Latest');
      record = new Latest();
      return patch.applyUpdates(record, {
        success: function() {
          return res.json(201, 'created');
        },
        error: function() {
          return res.json(500, 'not created');
        }
      });
    },
    update: function(record) {
      return patch.setPrevious(record, function(err, something) {
        if (err) {
          res.json(500, err);
          return;
        }
        return patch.applyUpdates(record, {
          success: function() {
            return res.json(200, 'updated');
          },
          error: function() {
            return res.json(500, 'not updated');
          }
        });
      });
    },
    error: function() {
      return res.json(500, 'unknown error');
    }
  });
});

app.listen();
